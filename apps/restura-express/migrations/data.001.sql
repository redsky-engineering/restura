create table company
(
    id           bigint generated always as identity (maxvalue 2147483647)
        primary key,
    "createdOn"  timestamp with time zone default now() not null,
    "modifiedOn" timestamp with time zone default now() not null,
    name         varchar(255)
);

alter table company
    owner to postgres;

create table "user"
(
    id                        bigint generated by default as identity (maxvalue 2147483647)
        primary key,
    "createdOn"               timestamp with time zone default now()                             not null,
    "modifiedOn"              timestamp with time zone default now()                             not null,
    "firstName"               varchar(30)                                                        not null,
    "lastName"                varchar(30)                                                        not null,
    "companyId"               bigint                                                             not null
        constraint "user_companyId_company_id_fk"
            references company,
    password                  varchar(70)                                                        not null,
    email                     varchar(100)                                                       not null
        constraint user_email_unique_index
            unique,
    role                      varchar(5)                                                         not null
        constraint role_check
            check ((role)::text = ANY ((ARRAY ['admin'::character varying, 'user'::character varying])::text[])),
    "permissionLogin"         boolean                  default true                              not null,
    "lastLoginOn"             timestamp with time zone,
    phone                     varchar(30),
    "loginDisabledOn"         timestamp with time zone,
    "passwordResetGuid"       varchar(100),
    "verifyEmailPin"          integer,
    "verifyEmailPinExpiresOn" timestamp with time zone,
    "accountStatus"           varchar(9)               default 'view_only'::character varying    not null
        constraint "accountStatus_check"
            check (("accountStatus")::text = ANY
                   ((ARRAY ['banned'::character varying, 'view_only'::character varying, 'active'::character varying])::text[])),
    "passwordResetExpiresOn"  timestamp with time zone,
    "onboardingStatus"        varchar(12)              default 'verify_email'::character varying not null
        constraint "onboardingStatus_check"
            check (("onboardingStatus")::text = ANY
                   ((ARRAY ['verify_email'::character varying, 'complete'::character varying])::text[])),
    "pendingEmail"            varchar(100),
    "testAge"                 integer                  default 0,
    metadata                  jsonb                    default '{}'::jsonb                       not null
);

alter table "user"
    owner to postgres;

create index "user_companyId_index"
    on "user" ("companyId");

create index "user_passwordResetGuid_index"
    on "user" ("passwordResetGuid");

create table "order"
(
    id            bigserial
        constraint order_pk
            primary key,
    "userId"      bigint not null
        constraint order_user_null_fk
            references "user",
    "amountCents" bigint
);

alter table "order"
    owner to postgres;

create table item
(
    id        bigint generated always as identity
        primary key,
    "orderId" bigint not null
);

alter table item
    owner to postgres;

create function notify_user_insert() returns trigger
    language plpgsql
as
$$
BEGIN
    PERFORM pg_notify('insert', json_build_object('table','user','query', current_query(), 'record', NEW, 'previousRecord', OLD)::text);
    RETURN NEW;
END;
$$;

alter function notify_user_insert() owner to postgres;

create trigger user_insert
    after insert
    on "user"
    for each row
execute procedure notify_user_insert();

create function notify_username_insert() returns trigger
    language plpgsql
as
$$
BEGIN
    PERFORM pg_notify('user_insert', current_query());
    RETURN NEW;
END;
$$;

alter function notify_username_insert() owner to postgres;

create function notify_user_update() returns trigger
    language plpgsql
as
$$
BEGIN
    PERFORM pg_notify('update', json_build_object('table','user','query', current_query(), 'record', NEW, 'previousRecord', OLD)::text);
    RETURN NEW;
END;
$$;

alter function notify_user_update() owner to postgres;

create trigger user_update
    after update
    on "user"
    for each row
execute procedure notify_user_update();

create function "notify_userOLD_insert"() returns trigger
    language plpgsql
as
$$
BEGIN
    PERFORM pg_notify('insert', json_build_object('table','user','query', current_query(), 'record', NEW, 'previousRecord', OLD)::text);
    RETURN NEW;
END;
$$;

alter function "notify_userOLD_insert"() owner to postgres;

create function notify_userold_insert() returns trigger
    language plpgsql
as
$$
BEGIN
    PERFORM pg_notify('insert', json_build_object('table','user','query', current_query(), 'record', NEW, 'previousRecord', OLD)::text);
    RETURN NEW;
END;
$$;

alter function notify_userold_insert() owner to postgres;

create function notify_order_delete() returns trigger
    language plpgsql
as
$$
BEGIN
    PERFORM pg_notify('delete', json_build_object('table','order','query', current_query(), 'record', NEW, 'previousRecord', OLD)::text);
    RETURN NEW;
END;
$$;

alter function notify_order_delete() owner to postgres;

create trigger order_delete
    after delete
    on "order"
    for each row
execute procedure notify_order_delete();